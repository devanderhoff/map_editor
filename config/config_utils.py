import pandas as pd
import numpy as np
from ruamel.yaml import YAML
from pathlib import Path
from typing import Any, Dict, List
import itertools
from tqdm import tqdm
import shutil
from utils.log import get_logger

logger = get_logger(__name__)


def product_dict(**kwargs):
    keys = kwargs.keys()
    vals = kwargs.values()
    for instance in itertools.product(*vals):
        yield dict(zip(keys, instance))


class TileTypeOverlayConfig:
    TILE_CONFIG_PATH: Path = Path(__file__).parent.joinpath('terrain_type_mapping.yaml')
    DEFAULT_TILE_PENALTY_TSV_PATH: Path = Path(__file__).parent.joinpath('subtile_combination_scores.tsv')
    PENALTY_COLNAME_AUTO = 'PENALTY_AUTO'
    PENALTY_COLNAME_MANUAL = 'PENALTY_MANUAL'
    COL_SEP = '\t'

    # !TODO write something like a get_score method, which returns the some function of the manual and auto penalties when the subtile combinations are passed.

    def __init__(self, random_initial_penalties: bool = True):
        self.tile_config: Dict[str, Dict[str, int]] = self.load_tile_config()
        self.meta_types: List[str] = list(self.tile_config.keys())

        self.cfg_combo_dframe: pd.DataFrame = pd.DataFrame()
        self.random_initial_penalties: bool = random_initial_penalties

    @classmethod
    def from_tsv(cls, tsv_path: Path = DEFAULT_TILE_PENALTY_TSV_PATH):
        """
        Used to load a TileTypeOverlayConfig object from a previously generated .TSV file.
        :param tsv_path: (Optional) pathlib.Path pointing to a .TSV file generated by this class.
        Defaults to the default path where this is stored as set in the
        DEFAULT_TILE_PENALTY_TSV_PATH class attribute.
        """
        cfg_instance = cls()
        cls.cfg_combo_dframe = pd.read_csv(filepath_or_buffer=tsv_path, sep=cls.COL_SEP)
        return cfg_instance

    def generate_config_file(self, tgt_path: Path = DEFAULT_TILE_PENALTY_TSV_PATH):
        """
        Generates a configuration dataframe with rows for each set of type: subtile type combinations.
        First two columns are penalties: one to be determined internally,
        and one to add manual biases to specific tile configurations.
        Dataframe is then written to .TSV file (Defaults to DEFAULT_TILE_PENALTY_TSV_PATH class attribute).
        """
        self.cfg_combo_dframe = self._init_combo_dframe()

        self.cfg_combo_dframe = self._fill_combo_dframe(combo_df=self.cfg_combo_dframe)

        self._backup_if_exists(tgt_path=tgt_path)

        self.cfg_combo_dframe.to_csv(path_or_buf=tgt_path, sep=self.COL_SEP, index=False)

        logger.info("Saved combo dataframe to %s", str(tgt_path.absolute()))

    def get_subtile_combos(self) -> List[Dict[str, str]]:
        """
        Get all combinations  as list of dicts with metatype: tile_subtype for each combination.

        For example:
        [{'CLIMATE': 'SEA', 'RELIEF': 'UNKNOWN', 'VEGETATION': 'NONE', 'WATER': 'NONE'},
         {'CLIMATE': 'SEA', 'RELIEF': 'UNKNOWN', 'VEGETATION': 'NONE', 'WATER': 'RIVER_SMALL'},
         ... ,
         {'CLIMATE': 'UNKNOWN', 'RELIEF': 'MOUNTAINS', 'VEGETATION': 'FOREST', 'WATER': 'SWAMP'}
        ]
        """
        return list(product_dict(**self.tile_config))

    def get_combo_dframe_column_names(self) -> List[str]:
        """
        Builds columns for dataframe (e.g. CLIMATE_SEA, CLIMATE_CONTINENTAL)
        """
        colnames = [self.PENALTY_COLNAME_MANUAL, self.PENALTY_COLNAME_AUTO]

        for tile_metatype, subtile_dict in self.tile_config.items():
            for subtile_type, subtile_id in subtile_dict.items():
                colnames.append('_'.join([tile_metatype, subtile_type]))
        return colnames

    def _init_combo_dframe(self,
                           score_dtype: np.dtype = np.int64,
                           mask_dtype: np.dtype = np.bool_) -> pd.DataFrame:

        colnames = self.get_combo_dframe_column_names()
        subtile_combos = self.get_subtile_combos()

        cfg_df = pd.DataFrame(columns=colnames,
                              data=np.zeros(shape=(len(subtile_combos), len(colnames)),
                                            dtype=mask_dtype))

        for colname in (self.PENALTY_COLNAME_AUTO, self.PENALTY_COLNAME_MANUAL):
            cfg_df[colname] = cfg_df[colname].astype(score_dtype)

        return cfg_df

    def _fill_combo_dframe(self,
                           combo_df: pd.DataFrame) -> pd.DataFrame:

        subtile_combos = self.get_subtile_combos()

        for icombo, combo in tqdm(enumerate(subtile_combos), total=len(subtile_combos),
                                  desc='Filling combo dataframe...',
                                  unit=' subtile type combinations'):
            for tile_metatype, subtile_type in combo.items():
                colname = '_'.join([tile_metatype, subtile_type])
                combo_df.loc[combo_df.index[icombo], colname] = True

        combo_df.loc[:, self.PENALTY_COLNAME_MANUAL] = np.zeros(shape=(combo_df.shape[0], 1))

        if self.random_initial_penalties:
            combo_df.loc[:, self.PENALTY_COLNAME_AUTO] = \
                np.random.randint(low=1, high=100, size=combo_df.shape[0])
        else:
            combo_df.loc[:, self.PENALTY_COLNAME_AUTO] = \
                np.zeros(shape=(combo_df.shape[0], 1))

        return combo_df

    def load_tile_config(self, path: Path = TILE_CONFIG_PATH) -> Dict[str, Dict[str, int]]:
        """
        Loads terrain type nested dict with as values int:value type maping.
        :param path: (Optional) pathlib.Path object pointing to config file
            (Default = TILE_CONFIG_PATH)
        """
        return self._load_yaml(path=path)

    @staticmethod
    def _backup_if_exists(tgt_path: Path):
        if tgt_path.exists():
            logger.info(''.join(["Found existing combo dataframe file; ",
                                 "copying current one to backup to prevent overwriting ",
                                 "of manually and painstakingly adjusted scores."]))
            backup_file_path = tgt_path.parent.joinpath(tgt_path.with_suffix(f'{tgt_path.suffix}.LAST').name)

            shutil.copy(src=tgt_path, dst=backup_file_path)

    @staticmethod
    def _load_yaml(path: Path) -> Dict[Any, Any]:
        return YAML(typ='safe').load(path)

    def __repr__(self):
        return f"{type(self).__name__}(meta_types={self.meta_types})"


if __name__ == '__main__':
    tov = TileTypeOverlayConfig()
    tov.generate_config_file()
